<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ACL访问控制列表实践</title>
      <link href="/2023/05/30/ACL%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%88%97%E8%A1%A8%E5%AE%9E%E8%B7%B5/"/>
      <url>/2023/05/30/ACL%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%88%97%E8%A1%A8%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>urllib3 Drop support for OpenSSL&lt;1.1.1 排障记录</title>
      <link href="/2023/05/30/urllib3-Drop-support-for-OpenSSL-1-1-1%E6%8E%92%E9%9A%9C%E8%AE%B0%E5%BD%95/"/>
      <url>/2023/05/30/urllib3-Drop-support-for-OpenSSL-1-1-1%E6%8E%92%E9%9A%9C%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>样式冲突太多，记一次前端CSS升级</title>
      <link href="/2023/05/22/%E6%A0%B7%E5%BC%8F%E5%86%B2%E7%AA%81%E5%A4%AA%E5%A4%9A%EF%BC%8C%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%89%8D%E7%AB%AFCSS%E5%8D%87%E7%BA%A7/"/>
      <url>/2023/05/22/%E6%A0%B7%E5%BC%8F%E5%86%B2%E7%AA%81%E5%A4%AA%E5%A4%9A%EF%BC%8C%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%89%8D%E7%AB%AFCSS%E5%8D%87%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>目前QAPM平台前端使用的是原生CSS+BEM命名，在多人协作的模式下，容易出现<strong>样式冲突</strong>。为了减少这一类的问题，提升研效，我调研了业界上主流的7种CSS解决方案，并将最终升级方案落地到了工程中。</p><h3 id="样式冲突的原因"><a href="#样式冲突的原因" class="headerlink" title="样式冲突的原因"></a>样式冲突的原因</h3><p>目前遇到的样式冲突的原因：</p><ol><li>多人协作，样式互相污染，这是项目中的主要问题。用开发规范来限定、用CR流程来保障，并不可靠</li><li>引用大量第三方组件库，组件库对CSS的使用不规范。比如bee.css中使用了大量<code>！important</code>，破坏了项目中的样式优先级；rsuit是前端非常强大的表格组件库，他的css文件中也有直接覆盖底层样式的写法<code>label&#123; marign:2px &#125;</code></li><li>直接使用组件库引入的css文件，比如<code>import material-icons.css</code>，如果引用顺序靠后，这些文件可能会覆盖开发人员手写的样式。</li><li>…</li></ol><h3 id="调研方案"><a href="#调研方案" class="headerlink" title="调研方案"></a>调研方案</h3><p>CSS作为前端三剑客之一，几乎是所有前端同学最先学习的样式表语言。在生产环境的项目工程中，很少见到直接原生使用CSS的。但目前业界还没有通用的CSS工程化方案。这篇文章先简单介绍下7种在React&#x2F;Next.js中较为流行使用CSS的方式，并说说他们的优缺点。</p><h3 id="原生-CSS"><a href="#原生-CSS" class="headerlink" title="原生 CSS"></a>原生 CSS</h3><p>这是一种用选择器来划分css作用域的方式。</p><ul><li>缺点：</li></ul><ol><li>作用域问题<br>CSS样式之间会层叠覆盖，需要用大量的classname来指定选择器，来限定CSS的作用域范围。频繁的命名给开发人员增加不少心智负担，而且容易搞错搞重复。<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// pure css example</span><br><span class="line"><span class="selector-class">.card</span> &#123;</span><br><span class="line"><span class="comment">/* styles */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.card__header</span> &#123;</span><br><span class="line"><span class="comment">/* styles */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.card--focus</span> &#123;</span><br><span class="line"><span class="comment">/* styles */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>采用BEM规则来进行命名或许会简单些。<br>但在需要维护特别多样式的时候，BEM还是不够用。尤其是当代码中开始大量出现<code>!important</code>这种破坏优先级的东西的时候。<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// css with !important</span><br><span class="line"><span class="selector-class">.card</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: blue <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.card</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>打包体积大<br>使用大量冗长的原生CSS，可能会导致<br>打出来的包变大。包越大，项目自然跑的就越慢。</li></ol><h3 id="CSS-MODULES"><a href="#CSS-MODULES" class="headerlink" title="CSS MODULES"></a>CSS MODULES</h3><p>这是一种在原生CSS的基础上，通过modules（也可以理解为文件）来划分CSS的作用域。</p><p>首先先建一些以.module.css结尾的文件，这些文件里的样式可以只针对某个组件（某个module）生效。这种做法在Next.js尤为常见，因为CSS modules在Next.js是可以开箱即用的。</p><p>下面是一个例子，在<code>Home.module.css</code>和<code>other.module.css</code>对<strong>同样的类名</strong>书写样式，也不会产生冲突。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@file</span> Home.module.css</span><br><span class="line">.page &#123;</span><br><span class="line"><span class="attribute">color</span>: bule;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@file</span> other.module.css</span><br><span class="line">.page &#123;</span><br><span class="line"><span class="attribute">color</span>: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只会生效这里import的样式</span></span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">&#x27;../styles/Home.module.css&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Home</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="comment">// 蓝色</span></span><br><span class="line">&lt;div className=&#123;styles.page&#125;&gt;</span><br><span class="line">&lt;h1&gt; Home Page &lt;/h1&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优势：</li></ul><ol><li>当需要复用样式的时候，不同的组件可以import同一份样式文件，减少很多重复样式代码，减轻打包体积～</li><li>说到样式复用，CSS modules还有个特殊的composes属性，能引入别的module的css样式，也能重写（override）。<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.page</span> &#123;</span><br><span class="line">composes: className from <span class="string">&quot;./shared.css&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>缺点：</li></ul><ol><li>不够“程序化”<br>CSS modules在原生CSS的基础上增加了以modules（文件）划分的作用域，解决了作用域问题，但仍逃不过在单个module内以原生的方式书写CSS。原生的CSS只能纯纯的枚举出每一条样式，如果能在书写CSS的时候也支持一些程序特性岂不是更好？比如最常用的循环、遍历、函数、继承…</li></ol><h3 id="CSS-PREPROCESSOR-预处理器"><a href="#CSS-PREPROCESSOR-预处理器" class="headerlink" title="CSS PREPROCESSOR 预处理器"></a>CSS PREPROCESSOR 预处理器</h3><p>Sass、Less、Stylus… 这些预处理器就是为了解决CSS不够“程序化”而诞生的。他们允许你用一种不一样的语法来写CSS，之后再经过编译转化成原生CSS。</p><p>这里是一个例子：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 只需一键安装sass</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm install sass</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// 然后把原本的css后缀文件改成scss</span><br><span class="line">// 就可以直接使用sass的方式来编写css啦，比如变量名、循环、...</span><br><span class="line">@ file Home.module.scss</span><br><span class="line"></span><br><span class="line">$ <span class="attribute">primary-color</span>: red;</span><br><span class="line">$ <span class="attribute">font</span>-stack：Helvetica</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line"><span class="attribute">font</span>: <span class="number">100%</span> $font-stack;</span><br><span class="line"><span class="attribute">color</span>: $primary-color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优势：</li></ul><ol><li>可以用变量、继承、循环、函数、…等程序特性</li></ol><ul><li>缺点：</li></ul><ol><li>学习成本<br>每种预处理器都有各自特定的语法，虽然是用一种类CSS的语言来编写，但总有有些差异。这意味着开发人员必须配合工具掌握新的语法。</li><li>样式和项目代码微微割裂<br>在解决完作用域、程序化问题后，样式在前端项目中完完全全的独立出来了，似乎少了一些联动能力。既然我们有JSX这样整合JS和HTML的合体语言，为什么不能把CSS也合体进来呢？</li></ol><h3 id="CSS-IN-JS"><a href="#CSS-IN-JS" class="headerlink" title="CSS IN JS"></a>CSS IN JS</h3><p>这是一种把CSS写进JS的解决方案，就像把HTML写进JS后就有了JSX。这一类的库有styled components、emotion、jss、style tron、…</p><p>举个使用styled jsx的例子：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">&#x27;../styles/Home.module.css&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Home</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">const</span> [color, serColor] = <span class="title function_">useState</span>(<span class="string">&#x27;orange&#x27;</span>);</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">&lt;div className=&#123;styles.page&#125;&gt;</span><br><span class="line">&lt;style jsx&gt;&#123;`</span><br><span class="line">h1 &#123;</span><br><span class="line">// 取的是组件state，可以随state变化！</span><br><span class="line">color: $&#123;color&#125;;</span><br><span class="line">&#125;</span><br><span class="line">`&#125;&lt;/style&gt;</span><br><span class="line">&lt;h1&gt; Home Page &lt;/h1&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优势：</li></ul><ol><li>轻松能实现的程序化能力<br>在sass里的程序化能力，CSS in JS都能做到，甚至更强，这种方式可以直接使用JS书写这种程序化语言，也不需要额外学习成本。</li><li>创建动态样式<br>在sass里，程序代码或许和样式文件是完全独立开来的。而使用CSS in JS，样式和JS强绑定，我们的样式能够跟着代码、跟着组件的state等特性实现动态样式，特别灵活！</li><li>不会有作用域问题<br>类似module，CSS in JS的样式只会绑定在样式定义的组件内，不会污染全局样式～</li></ol><ul><li>缺点：</li></ul><ol><li>CSS和JS混写，代码管理困难。</li></ol><h3 id="UTILITY-CLASSES-原子类"><a href="#UTILITY-CLASSES-原子类" class="headerlink" title="UTILITY CLASSES 原子类"></a>UTILITY CLASSES 原子类</h3><p>时下最火的新概念就是tailwindcss、windi css这些原子类CSS库，能够提供大量的原子类样式，帮助我们快速构建样式。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 配置好tailwind之后</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Home</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="comment">// 在这里写上tailwind的原子类classname，而不需要写样式</span></span><br><span class="line">&lt;div className=&quot;text-5xl font-bold&quot;&gt;</span><br><span class="line">&lt;h1&gt; Home Page &lt;/h1&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>缺点</li></ul><ol><li>需要比较麻烦的额外配置</li><li>打包后，生成的HTML文件可读性非常非常低<br><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/77ff846122eb448ab0d3129739c252e1~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></li><li>没有任何的内置组件</li></ol><ul><li>优势</li></ul><ol><li>打包时，能自动优化，去除没有使用的css样式，减轻打包产物体积。</li></ol><h3 id="CSS-FRAMEWORK"><a href="#CSS-FRAMEWORK" class="headerlink" title="CSS FRAMEWORK"></a>CSS FRAMEWORK</h3><p>bootstrap、bulma、这一类库既能提供特定的样式主题，又有内置的组件，比如bottom、cards、…等等。我个人在自己倒腾东西的时候非常喜欢用这一类框架，因为实在是太方便啦！这种方式在生产上几乎很少采用，因为开发人员往往需要根据产品原型来绘制前端界面，而不是这些框架固定的样式。另外采用这种方式，也容易对线上性能造成比较大影响。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 想使用这一类框架，只用一键安装上</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm install bootstrap</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入框架的样式文件</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;bootstrap/dist/css/bootstrap.css&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Home</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="comment">// 想要使用的样式都在bootstrap中用各种classname封装好啦，直接调用boostrap的预留classname，搞定</span></span><br><span class="line">&lt;div className=&quot;alert alert-primary&quot;&gt;</span><br><span class="line">&lt;h1&gt; Home Page &lt;/h1&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>缺点：</li></ul><ol><li>在只使用bootstrap来搭建组件和修改样式的话，会不太方便<br>由于这类框架已经自带了许多预留组件，而bootstrap的样式又是用classname来获取的。假设我需要频繁使用<code>&lt;Bottom /&gt;</code>组件，却又不想在每次使用的时候，都重复的写相同的classname，那么就会将他们封装成<code>&lt;CustomButtom /&gt;</code>。这么做的话，项目代码中就可能会有大量的仅仅是为了封装classname而存在的组件。</li><li>打包文件过大<br>整个bootstrap文件是直接import进来的。因此在打包时，会把大量没使用到的classname也打包进来，会造成打包产物较大～</li></ol><h3 id="组件库"><a href="#组件库" class="headerlink" title="组件库"></a>组件库</h3><p>这是大家最熟悉的方式啦，ant design、material design、t design、rebase、….</p><h3 id="最终落地的升级方案"><a href="#最终落地的升级方案" class="headerlink" title="最终落地的升级方案"></a>最终落地的升级方案</h3><p>不同的CSS处理方式各有优劣，在实际开发中，可以自行选择和搭配合适的CSS处理手段。</p><p>在我目前工作中，是将项目的原生CSS，升级成css module + less 的组合，这样既能解决当前项目的核心矛盾：作用域和样式污染问题，又能让CSS的编写过程变得更“程序”，比如使用变量、继承等特性。</p><p>没有使用css in js 是因为当前项目没有主题切换和动态样式这样场景，此外css in js 会让一个组件文件变得非常冗长，尤其是目前我的工作特别多复杂图表的封装，仅jsx部分代码行数已经非常长，再引入CSS代码容易变得更混乱。我个人也更加偏向能用独立文件区分出CSS代码的方式，这样展示出更好的项目分层。</p><p>没有使用原子类的理由就更简单了，配置麻烦，可读性低，而且对团队内每个人都有较高的学习成本，不方便团队管理，直接pass了。</p><p>在前端工程开发的过程中，面对多人协作的场景，建立标准和团队内的规范是非常重要的一个环节。尤其当前业界的前端，就是没有通用标准的情况下，影响项目工程稳健性的往往是缺乏规范和标准，而不是开发人员的水平。在我工作的项目中，最初就是因为大量人员流动，大家在项目中各按各自的方式写CSS，导致在一个项目中存在3种以上CSS写法，非常难维护，也出现了样式互相污染、互相冲突的情况，所以才有了这次对CSS的调研，以及对项目进行升级和改造的工作。</p><p>附上一些参考资料：</p><p><a href="https://webflow.com/blog/class-naming-101-bem">https://webflow.com/blog/class-naming-101-bem</a></p><p><a href="https://www.nextjs.cn/">https://www.nextjs.cn/</a></p><p><a href="https://www.tailwindcss.cn/">https://www.tailwindcss.cn/</a></p><p><a href="https://www.youtube.com/watch?v=ouncVBiye_M">https://www.youtube.com/watch?v=ouncVBiye_M</a></p><p><a href="https://www.youtube.com/watch?v=hdGsFpZ0J2E">https://www.youtube.com/watch?v=hdGsFpZ0J2E</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/05/22/hello-world/"/>
      <url>/2023/05/22/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
